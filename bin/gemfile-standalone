#!/usr/bin/env ruby
# encoding: UTF-8
require 'pathname'
require 'strscan'

class DotGemsParser
  class ParseError < RuntimeError; end
  attr_reader :gems

  def self.[](*a)
    new(*a).parse.gems
  end

  def initialize(io, filename="-")
    io ||= open(filename)
    @s, @filename = io.read.gsub(/\r\n?/, "\n").sub(/\Z\n?/, "\n"), filename
  end

  def parse
    @ss   = StringScanner.new(@s)
    @gems = {}
    # tokenization
    until @ss.eos?
      @ss.skip(/^[\t ]*(#.*)?\n/) and next
      @ss.skip(/[\t ]+/)
      options     = { :pos => @ss.pos }
      name        = @ss.scan(/\S+/) or raise_parse_error("Don't know what to do with:")
      @gems[name] = options
      until @ss.skip(/[\t ]*\n/)
        @ss.skip(/[\t ]+/)
        if @ss.scan(/-\w|--\w\w+/) and key = @ss[0]
          @ss.skip(/[\t ]*(=[\t ]*)?/)
          @ss.scan(/'(.*?)(?!<\\)'/) or
          @ss.scan(/"(.*?)(?!<\\)"/) or
          @ss.scan(/(\S+)/)          or raise_parse_error("Expected value for key #{key} in", @ss.pos, options[:pos])
          options[key] = @ss[1]
          @ss.skip(/[\t ]+/)
        else @ss.skip(/#.*/) or raise_parse_error("Unexpected:")
        end
      end
    end
    # semantic validation
    @gems.each do |name, options|
      s = options.delete("-s") || options.delete("--source")  and options[:source]  = s
      v = options.delete("-v") || options.delete("--version") and options[:version] = v
      invalid_keys = options.keys - [:source, :version, :pos]
      invalid_keys.empty? or raise_parse_error("Invalid options for gem '#{name}': #{invalid_keys.join(",")} in", options[:pos])
    end
    self
  end

  def raise_parse_error(message, pos = @ss.pos, peek_pos = pos)
    line = @s[0...pos].scan(/\n/).length + 1
    col  = @s[0...pos].sub(/.*\n/m, '').length + 1
    peek = @s[peek_pos..-1][/\A.*/]
    raise ParseError, "#{message} #{peek.inspect} in #{@filename} line #{line}, col #{col}"
  end
end

require 'stringio'

class GemfileWriter
  def initialize(gems_hash)
    @io           = StringIO.new
    gems_by_group = gems_hash.inject({}) { |h, (k, v)| (h[v[:group]]||={})[k] = v; h }
    sources       = gems_hash.values.map { |options| options[:source] }.compact.uniq
    sources      -= %w[ gems.rubyforge.org gemcutter.org rubygems.org ]
    @io.puts "source :rubygems"
    sources.each { |source| @io.puts "source #{source.inspect}" }
    gems_by_group.entries.sort_by { |k, v| k.to_s }.each do |group, gems|
      @io.puts
      @io.puts "group #{group.inspect} do" if group
      gems.each do |name, options|
        @io.print "  " if group
        @io.puts  "gem #{[name, options[:version]].compact.map(&:inspect).join(', ')}"
      end
      @io.puts "end" if group
    end
  end

  def string
    @io.string
  end
  alias_method :to_s, :string

  def write(path = "Gemfile")
    open(path, "w") { |io| io.write string }
  end
end


unless (ARGV & %w[ -h --help -? --usage ]).empty?
  puts DATA.read.gsub(/\$0/, File.basename($0))
  exit 0
end

begin
  puts GemfileWriter.new(DotGemsParser[ARGF, ARGF.filename])
rescue DotGemsParser::ParseError => e
  $stderr.puts e
  exit 1
end

__END__
Convert Heroku gem manifest format (.gems) to Bundler format (Gemfile)

  Usage:
    $0 dot-gems-file [, dot-gems-file ...]
    $0 < .gems
    $0 < .gems > Gemfile
